#include "ezGfx_core.h"

#include <time.h>
#include <pthread.h>
#include <string.h>

#include <linux/fb.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <fcntl.h>

//https://cmcenroe.me/2018/01/30/fbclock.html

static struct timespec startTime;
static struct timespec lastTime;
static volatile bool running;
static pthread_t thread;
static void* mainThread(void* arg);

static EZ_Image canvas;
static int winWidth;
static int winHeight;
static u32* buffer;
static int fb
static struct fb_var_screeninfo screenInfo;


static int keyMap(int keyCode);
static EZ_Key keyStates[_numberOfKeys];
static EZ_Mouse mouseState;


void EZ_window(const char* name, int w, int h, EZ_Image cnvs) {

	canvas = cnvs;

	//INIT GFX
	//https://docs.huihoo.com/doxygen/linux/kernel/3.7/structfb__var__screeninfo.html

	//open the linux frame buffer device directly 
	fb = open("/dev/fb0", O_RDWR);
	ASSERTM(fb > 0, "Couldn't open frame buffer");

	//get screen info
	ASSERT(0 == ioctl(fb, FBIOGET_VSCREENINFO, &screenInfo));
	
	winWidth  = screenInfo.xres; 
	winHeight = screenInfo.yres;

	//get handle to screen buffer
	size_t len = sizeof(u32) * screenInfo.xres * screenInfo.yres;
	buffer = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fb, 0);
	ASSERTM(buffer != MAP_FAILED, "Couldn't map the frame buffer");

	ASSERTM(screenInfo.bits_per_pixel == 32, "Unsupported pixel format");


}

void EZ_start() {
	running = true;
	pthread_create(&thread, NULL, &mainThread, NULL);
}

void EZ_stop() {
	running = false;
}

void EZ_join() {
	pthread_join(thread, NULL);
}

double EZ_getTime() {
	struct timespec now;
	clock_gettime(CLOCK_MONOTONIC, &now);

	double time = (now.tv_sec - startTime.tv_sec) + (now.tv_nsec - startTime.tv_nsec) / 1000000000.0;

	return time;
}

EZ_Key EZ_getKey(enum EZ_KeyCodes code) {
	return keyStates[code];
}

EZ_Mouse EZ_getMouse() {
	return mouseState;
}


void EZ_rename(const char* name) {
}

void EZ_resize(int w, int h) {

}

void EZ_setFullscreen(bool val) {
	
}

void EZ_setMaximized(bool val) {
	
}

void EZ_setStretching(bool val) {

}


EZ_Image EZ_createImage(int w, int h) {
	EZ_Image img = {0};
	img.w = w;
	img.h = h;
	img.px = calloc(w*h, sizeof(EZ_Px));

	return img;
}

EZ_Image EZ_copyImage(EZ_Image source) {

	EZ_Image img = {0};
	img.w = source.w;
	img.h = source.h;

	img.px = malloc(img.w*img.h*sizeof(EZ_Px));
	memcpy(img.px, source.px, img.w*img.h*sizeof(EZ_Px));

	return img;
}

void EZ_freeImage(EZ_Image img) {
	if (img.px != NULL) free(img.px);
}


EZ_Px EZ_randCol() {
	EZ_Px col;
	col.ref = (long)rand() << 8;
	return col;
}

EZ_Px EZ_blend(EZ_Px fg, EZ_Px bg, enum EZ_blendMode mode) {
	//https://love2d.org/wiki/BlendMode_Formulas
	EZ_Px result;

	switch (mode) {
		case ALPHA_IGNORE : result = fg; break;
		case ALPHA_FAST   : result = (fg.col.a == 0) ? bg : fg; break;

		default :
		case ALPHA_BLEND  : 
		
		//integer math only	optimization
		result.col.a = fg.col.a + (255 - fg.col.a) * bg.col.a;
		result.col.r = (fg.col.a * fg.col.r + (255 - fg.col.a) * bg.col.r) >> 8;
		result.col.g = (fg.col.a * fg.col.g + (255 - fg.col.a) * bg.col.g) >> 8;
		result.col.b = (fg.col.a * fg.col.b + (255 - fg.col.a) * bg.col.b) >> 8;


		break;


	}


	return result;
}


void EZ_redraw() {

	//time
	struct timespec now;
	clock_gettime(CLOCK_MONOTONIC, &now);
	double elapsedTime = (now.tv_sec - lastTime.tv_sec) + (now.tv_nsec - lastTime.tv_nsec) / 1000000000.0;
	lastTime = now;

	//user function
	EZ_callback_draw(elapsedTime);

	//TODO drawing

	for (int x = 0; x < canvas.w && x < winWidth;  x++)
	for (int y = 0; y < canvas.h && y < winHeight; y++) {
		//reverse endianness
		EZ_Px px = canvas.px[x + y*canvas.w];
		buffer[x + y*winWidth] = px.col.b << 0 | px.col.g << 8 | px.col.r << 16 | px.col.a << 24;
	}

}






/* PRIVATE */


static int keyMap(int keyCode) {
	//https://cgit.freedesktop.org/xorg/proto/x11proto/tree/keysymdef.h

	switch (keyCode) {
		case 0x41 : return K_SPACE;   case 0x16 : return K_BACKSPACE;
		case 0x09 : return K_ESCAPE;  case 0x17 : return K_TAB;
		case 0x24 : return K_RETURN;
		case 0x32 : return K_LSHIFT;  case 0x3e : return K_RSHIFT;
		case 0x25 : return K_LCTRL;   case 0x69 : return K_RCTRL;
		case 0x40 : return K_LALT;    case 0x6c : return K_RALT;
		case 0x42 : return K_CAPS;    case 0x4d : return K_NUMLOCK;
		case 0x4e : return K_SCROLL;  case 0x7f : return K_PAUSE;
		case 0x76 : return K_INS;     case 0x77 : return K_DEL;
		case 0x6e : return K_HOME;    case 0x73 : return K_END;
		case 0x70 : return K_PGUP;    case 0x75 : return K_PGDN;
		case 0x71 : return K_LEFT;    case 0x6f : return K_UP;
		case 0x72 : return K_RIGHT;   case 0x74 : return K_DOWN;

		case 0x3c : return K_PERIOD;
		case 0x2f : return K_COLON;   case 0x3b : return K_COMMA;
		case 0x30 : return K_QUOTE;   case 0x31 : return K_TILDE;
		case 0x3d : return K_SLASH;   case 0x33 :  return K_BACKSLASH;
		case 0x22 : return K_OPEN;    case 0x23 : return K_CLOSE;
		case 0x15 : return K_PLUS;    case 0x14 : return K_MINUS;

		case 0x5b : return KP_DEC;  case 0x68 : return K_RETURN;
		case 0x3f : return KP_MUL;  case 0x6a : return KP_DIV;
		case 0x56 : return K_PLUS;  case 0x52 : return K_MINUS;

		case 0x5a : return KP_0;  case 0x57 : return KP_1;  case 0x58 : return KP_2;
		case 0x59 : return KP_3;  case 0x53 : return KP_4;  case 0x54 : return KP_5;
		case 0x55 : return KP_6;  case 0x4f : return KP_7;  case 0x50 : return KP_8;
		case 0x51 : return KP_9;

		case 0x13 : return K_0;   case 0x0a : return K_1;   case 0x0b : return K_2;
		case 0x0c : return K_3;   case 0x0d : return K_4;   case 0x0e : return K_5;
		case 0x0f : return K_6;   case 0x10 : return K_7;   case 0x11 : return K_8;
		case 0x12 : return K_9;

		case 0x43 : return K_F1;  case 0x44 : return K_F2;  case 0x45 : return K_F3;
		case 0x46 : return K_F4;  case 0x47 : return K_F5;  case 0x48 : return K_F6;
		case 0x49 : return K_F7;  case 0x4a : return K_F8;  case 0x4b : return K_F9;
		case 0x4c : return K_F10; case 0x5f : return K_F11; case 0x60 : return K_F12;

		case 0x18 : return K_Q;   case 0x19 : return K_W;   case 0x1a : return K_E;
		case 0x1b : return K_R;   case 0x1c : return K_T;   case 0x1d : return K_Y;
		case 0x1e : return K_U;   case 0x1f : return K_I;   case 0x20 : return K_O;
		case 0x21 : return K_P;   case 0x26 : return K_A;   case 0x27 : return K_S;
		case 0x28 : return K_D;   case 0x29 : return K_F;   case 0x2a : return K_G;
		case 0x2b : return K_H;   case 0x2c : return K_J;   case 0x2d : return K_K;
		case 0x2e : return K_L;   case 0x34 : return K_Z;   case 0x35 : return K_X;
		case 0x36 : return K_C;   case 0x37 : return K_V;   case 0x38 : return K_B;
		case 0x39 : return K_N;   case 0x3a : return K_M;

		default : return K_ERROR;
	}
}



static void* mainThread(void* arg) {

	pthread_detach(pthread_self());

	//init time
	clock_gettime(CLOCK_MONOTONIC, &startTime);
	clock_gettime(CLOCK_MONOTONIC, &lastTime);

	//init keys
	for (int i = 0; i < _numberOfKeys; i++)
		keyStates[i].keyCode = i;

	//client init callback
	EZ_callback_init();


	//main loop
	while (running) {

		//TODO events, inputs
		for (int i = 0; i < _numberOfKeys; i++) {
			keyStates[i].pressed  = false;
			keyStates[i].released = false;
		}

		//display
		EZ_redraw();


	}


	EZ_callback_kill();
	
	//garbage collection
	munmap(buffer, sizeof(u32) * winHeight * winWidth);
	close(fb);
	pthread_exit(NULL);

	return NULL;
}
